import com.tep.qtestwrapper.config.AuthConfig;
import com.tep.qtestwrapper.model.AuthCredentials;
import com.tep.qtestwrapper.model.User;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.http.HttpStatus;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;

import java.util.Arrays;
import java.util.Collections;

import static org.mockito.Mockito.*;

class YourServiceTest {

    @Mock
    private AuthConfig authConfig;

    @Mock
    private ServerWebExchange exchange;

    @InjectMocks
    private YourService yourService;  // Replace with your actual service class name

    @BeforeEach
    void setup() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testValidateClientIdAndRoleInUrl_InvalidUrl() {
        Mono<User> result = yourService.validateClientIdAndRoleInUrl("client1", "invalidurl", exchange);
        StepVerifier.create(result)
                .expectComplete()
                .verify();

        // Add verification for the onError method call with "Invalid URL format"
        // This could be done by mocking the onError method
    }

    @Test
    void testValidateClientIdAndRoleInUrl_ClientIdNotFound() {
        AuthCredentials credentials = mock(AuthCredentials.class);
        when(authConfig.getCredentials()).thenReturn(credentials);
        when(credentials.getUsers()).thenReturn(Collections.emptyList());

        Mono<User> result = yourService.validateClientIdAndRoleInUrl("client1", "/role", exchange);
        StepVerifier.create(result)
                .expectComplete()
                .verify();

        // Add verification for the onError method call with "Client ID not found"
    }

    @Test
    void testValidateClientIdAndRoleInUrl_RoleNotMappedForClientId() {
        String clientId = "client1";
        String originalUrl = "/role";

        AuthCredentials credentials = mock(AuthCredentials.class);
        User user = null; // Simulate no user found

        when(authConfig.getCredentials()).thenReturn(credentials);
        when(credentials.getUsers()).thenReturn(Arrays.asList(
                new User(clientId, "someRole") // Mock a user with a different role
        ));
        when(yourService.getRoleByClientId(clientId, credentials)).thenReturn(user);

        Mono<User> result = yourService.validateClientIdAndRoleInUrl(clientId, originalUrl, exchange);
        StepVerifier.create(result)
                .expectComplete()
                .verify();

        // Add verification for the onError method call with "Role is not mapped for clientId"
    }

    @Test
    void testValidateClientIdAndRoleInUrl_RoleIsNull() {
        String clientId = "client1";
        String originalUrl = "/role";

        AuthCredentials credentials = mock(AuthCredentials.class);
        User userWithNullRole = new User(clientId, null); // User has null role

        when(authConfig.getCredentials()).thenReturn(credentials);
        when(credentials.getUsers()).thenReturn(Arrays.asList(userWithNullRole));
        when(yourService.getRoleByClientId(clientId, credentials)).thenReturn(userWithNullRole);

        Mono<User> result = yourService.validateClientIdAndRoleInUrl(clientId, originalUrl, exchange);
        StepVerifier.create(result)
                .expectComplete()
                .verify();

        // Add verification for the onError method call with "Role is not mapped for clientId"
    }

    @Test
    void testValidateClientIdAndRoleInUrl_RoleDoesNotMatch() {
        String clientId = "client1";
        String originalUrl = "/admin"; // Role in URL

        AuthCredentials credentials = mock(AuthCredentials.class);
        User userWithDifferentRole = new User(clientId, "user"); // Different role

        when(authConfig.getCredentials()).thenReturn(credentials);
        when(credentials.getUsers()).thenReturn(Arrays.asList(userWithDifferentRole));
        when(yourService.getRoleByClientId(clientId, credentials)).thenReturn(userWithDifferentRole);

        Mono<User> result = yourService.validateClientIdAndRoleInUrl(clientId, originalUrl, exchange);
        StepVerifier.create(result)
                .expectComplete()
                .verify();

        // Add verification for the onError method call with "Role is not matched. Access denied"
    }

    @Test
    void testValidateClientIdAndRoleInUrl_Success() {
        String clientId = "client1";
        String originalUrl = "/role";

        AuthCredentials credentials = mock(AuthCredentials.class);
        User userWithMatchingRole = new User(clientId, "role");

        when(authConfig.getCredentials()).thenReturn(credentials);
        when(credentials.getUsers()).thenReturn(Arrays.asList(userWithMatchingRole));
        when(yourService.getRoleByClientId(clientId, credentials)).thenReturn(userWithMatchingRole);

        Mono<User> result = yourService.validateClientIdAndRoleInUrl(clientId, originalUrl, exchange);
        StepVerifier.create(result)
                .expectNext(userWithMatchingRole)
                .verifyComplete();

        // Add verification for the successful validation log message
    }
}
